/******************************************************************************
 * 
 * Filename: hmc_eng.h
 *
 * Contents: #defs, typedefs, and function prototypes for routines that handle
 *    engineering registers
 *
 ******************************************************************************
 * A product of
 * Aclara Technologies LLC
 * Confidential and Proprietary
 * Copyright 2012-2021 Aclara.  All Rights Reserved.
 *
 * PROPRIETARY NOTICE
 * The information contained in this document is private to Aclara Technologies LLC an Ohio limited liability company
 * (Aclara).  This information may not be published, reproduced, or otherwise disseminated without the express written
 * authorization of Aclara.  Any software or firmware described in this document is furnished under a license and may be
 * used or copied only in accordance with the terms of such license.
 ******************************************************************************
 *
 * $Log$ kad Created 080707
 *
 ******************************************************************************
 * Revision History:
 * v0.1 - Initial Release
 * v0.2 - Added HMC_ENG_PROCEDURE_CHK to HMC_ENG_LIST.
 *****************************************************************************/

#ifndef hmc_eng_H
#define hmc_eng_H

/* INCLUDE FILES */

#include "project.h"
#include "psem.h"

/* CONSTANT DEFINITIONS */

enum HMC_ENG_LIST
{
   HMC_ENG_NAK = 0,
   HMC_ENG_PCKT_RESP,
   HMC_ENG_TIME_OUT,
   HMC_ENG_RETRY,
   HMC_ENG_CRC16,
   HMC_ENG_OVERRUN,
   HMC_ENG_TOTAL_SESSIONS,
   HMC_ENG_TOTAL_PACKETS,
   HMC_ENG_ABORT,
   HMC_ENG_GEN_ERROR,
   HMC_ENG_INV_REG,
   HMC_ENG_COM_TIME_OUT,
   HMC_ENG_RE_INIT,
   HMC_ENG_APPLET_ERROR,
   HMC_ENG_APPLET_TIMER_OUT,
   HMC_ENG_TOGGLE_ERROR,
   HMC_ENG_INTER_CHAR_T_OUT,
   HMC_ENG_PROCEDURE_CHK,     /* Command to check procedure results in an RX string from the host mtr. */
   HMC_ENG_HDWR_BSY
};
#define HMC_ENG_VARDATA   (HMC_COM_INFO *)RESP_OK

/* MACRO DEFINITIONS */

/* TYPE DEFINITIONS */
/*lint -esym(754,hwb,lenOffset,rsvd,procTableId,serialDate,serialTime) */
PACK_BEGIN
typedef struct PACK_MID
{
   uint16_t   retry; /* This field contains the number of Retry errors. This count indicates the number of times the
                        EMA resent a packet to the end device. If the EMA has retries configured, the EMA will retry
                        the packet after a NAK is received from the end device or after a Packet Time Out failure. If
                        the EMA does not have retries configured, this field will not increment. */
   uint8_t    pto;   /* This field contains the number of Packet Time Out errors. This count indicates the number of
                        times the EMA did not receive a response from the end device. If the EMA is configured for
                        retries, the EMA will retry the packet exchange when a Packet Time Out occurs. */
   uint16_t   nakr;  /* This field contains the number of NAKs the EMA received from the end device. If the EMA is
                        configured for retries, the EMA will retry the packet exchange when a NAK is received. */
   unsigned or : 4;  /* This field contains the number of times the data from the end device Overran the EMA's receive
                        buffer. The EMA will abort the session with the end device when an Overrun occurs. */
   unsigned tog: 4;  /* This field contains the number of times the Toggle Bit from the end device incorrectly remained
                        in the same state compared to the state the EMA expected to receive. The EMA will abort the
                        session with the end device when a Toggle Bit error occurs. */
   uint8_t    nakt;  /* This field contains the number of times the EMA transmits a NAK to the end device. NAKT
                        increments when the CRC16 from the end device failed to match the EMA's calculated CRC16 based
                        on the data received from the end device or when an intercharacter delay occurs and prevents a
                        complete packet from being received. */
   uint16_t   hwb;   /* This field contains the number of Hardware Busy counts. The number of times the physical busy
                        signal, generated by the end device, indicated busy and prevented the start of a session. */
} HostMtrCommExceptionCnts_t; /* Host Meter Communication Exception Counts*/
PACK_END

PACK_BEGIN
typedef struct PACK_MID
{
   uint16_t abort;      /* This field contains the number of times the EMA Aborted a communication session with the end
                           device. An Abort will occur after an Overrun error, a Toggle Bit error, or after the end
                           device and EMA retries are exhausted. */
   uint8_t  sessions[3];/* This field contains the number of communication Sessions with the end device. A Session is
                           counted every time the EMA attempts a login request. */
   uint32_t packets;    /* This field contains the number of Packet exchanges the EMA attempted with the end device. A
                           Packet exchange is counted when the EMA initiates sending a Packet. This field does not
                           include retry attempts */
} HostMtrCommPerfSum_t; /* Register 1511.1 - Host Meter Communication Performance Summary */
PACK_END

PACK_BEGIN
typedef struct PACK_MID
{
   uint8_t    onp;      /* This field contains the number of Operation Not Possible (the end device indicates that the
                           message was valid, but the message could not be processed; covers conditions such as invalid
                           length and invalid offset) errors during the ANSI C12.18 protocol exchange. Number of times
                           the EMA received an ONP error from the end device during a table access request. */
   uint8_t    iar;      /* This field contains the number of Inappropriate Action Requested (the end device indicates
                           that the action requested was inappropriate; covers conditions such as write request to a
                           read-only table or an invalid table ID) errors during the ANSI C12.18 protocol exchange.
                           Number of times the EMA received an IAR error from the end device during a table access
                           request. */
   uint8_t    isss;     /* This field contains the number of Invalid Service Sequence State (the end device indicates
                           that the request is not accepted at the current service sequence state) errors during the
                           ANSI C12.18 protocol exchange. Number of times the EMA received an ISSS error from the end
                           device during a table access request. */
   uint8_t    bsy;      /* This field contains the number of Busy (the end device indicates that the request was not
                           acted upon because the device was busy doing something else; the operation may be retried at
                           a later time) errors during the ANSI C12.18 protocol exchange. Number of times the EMA
                           received a BSY error from the end device during a table access request. */
   unsigned isc: 4;     /* This field contains the number of Insufficient Security Clearance (the end device indicates
                           that the current authorization level is insufficient to complete the request) errors during
                           the ANSI C12.18 protocol exchange. Number of times the EMA received an ISC error from the
                           end device during a table access request. */
   unsigned err: 4;     /* This field contains the number of Error (the end device indicates that the service request
                           was rejected; the reason for the rejection is not provided) errors during the ANSI C12.18
                           protocol exchange. Number of times the EMA received an ERR error from the end device during
                           a table access request. */
   unsigned sns: 4;     /* This field contains the number of Service Not Supported (the end device indicates that the
                           requested service is not supported; the message was valid, but the request could not be
                           honored) errors during the ANSI C12.18 protocol exchange. Number of times the EMA received a
                           SNS error from the end device during a table access request. */
   unsigned dnr: 4;     /* This field contains the number of Data Not Ready (the end device indicates that the request
                           was unsuccessful because the requested data is not ready to be accessed) errors during the
                           ANSI C12.18 protocol exchange. Number of times the EMA received a DNR error from the end
                           device during a table access request. */
   unsigned rno: 4;     /* This field contains the number of Renegotiate Request (the end device wishes to return to the
                           ID or Base State and renegotiate communication parameters) errors during the ANSI C12.18
                           protocol exchange. Number of times the EMA received an RNO error from the end device during
                           a table access request. */
   unsigned dlk: 4;     /* This field contains the number of Data Locked (the end device indicates that the request was
                           unsuccessful because the data cannot be accessed) errors during the ANSI C12.18 protocol
                           exchange. Number of times the EMA received a DLK error from the end device during a table
                           access request. */
} ansiCResponseCodeErrs_t; /* ANSI C12.18 Response Code Errors */
PACK_END

PACK_BEGIN
typedef struct PACK_MID
{
   uint16_t   dle;         /* This field contains the sum of the EMA's exception counts in Register #1510, except RETRY
                              since that value is already a sum of other fields in that register (HWB + NAKT + OR + TOG
                              + NAKR + PTO). */
   uint16_t   ansie;       /* This field contains the sum of the EMA's ANSI C12.18 errors in Register #1526 (RNO + DLK +
                              SNS + DNR + ISC + ERR + BSY + ISSS + IAR + ONP). */
   unsigned hwe: 4;        /* This field contains the number of times the EMA's communication applet fails to read or
                              write the register data. The hardware error could be NV memory access or a register size
                              error. */
   unsigned ae : 4;        /* This field contains the sum of the EMA's communication applet errors (IR + ATO + HWE). */
   unsigned ir : 4;        /* This field contains the number of times the EMA's communication applet attempted to access
                              an invalid RCE register. */
   unsigned ato: 4;        /* This field contains the number of times the EMA's communication applet timed out. */
} HostMtrCommErrCntSum_t;  /* 15.48 HOST METER COMMUNICATION ERROR COUNT SUMMARY (#1527) */
PACK_END

PACK_BEGIN
typedef struct PACK_MID
{
   uint16_t   serialDate;           /* Date of the last error event */
   uint16_t   serialTime;           /* Time of the last error event */

   union
   {
#if   defined(__PICC18__)
      struct
      {
         unsigned offsetMsb   : 8;
         unsigned length      : 4;  /* Length of data requested from host meter. Len > 15 will be reported as 15. */
         unsigned offsetLsb   : 4;  /* Offset Requested from host meter: Offset > 4095 will be reported as 4095 */
      } lenOffsetBits;
#else
      struct
      {
         unsigned length      : 4;  /* Length of data requested from host meter. Len > 15 will be reported as 15. */
         unsigned offset      : 12;
      } lenOffsetBits;
#endif
      uint16_t lenOffset;           /* Used to write offset in a single C instruction. */
   } uLenOffset;                    /* If TX packet doesn't contain table information, these fields will be zeroes. */

   union
   {
#if   defined(__PICC18__)
      struct
      {
         /* the variable procTableId is referred to as TARG (target) in the PDS */
         unsigned procTableIdMsb : 4;  /* MSB of the Procedure from Rx buffer or Table ID being requested (Tx buffer) */
         unsigned rsvd           : 2;
         unsigned write          : 1;  /* 0 = Read Operation, 1 = Write Operation */
         unsigned procedure      : 1;  /* 0 = Table Results, 1 = Procedure Results */
         unsigned procTableIdLsb : 8;  /* LSB of the procedure from Rx buffer or table ID being requested (Tx buffer) */
      } tblElements;
#else
      struct
      {
         /* the variable procTableId is referred to as TARG (target) in the PDS */
         unsigned procedure      : 1;  /* 0 = Table Results, 1 = Procedure Results */
         unsigned write          : 1;  /* 0 = Read Operation, 1 = Write Operation */
         unsigned rsvd           : 2;
         unsigned procTableId    : 12; /* Procedure from Rx buffer or Table ID being requested (Tx buffer) */
      } tblElements;
#endif
      uint16_t procTableID;            /* Note:  the MS bits are really the procedure and write flags! */
   } uTblId;
   uint8_t resultCode;                 /* PSEM response code or procedure result code. Both from Rx buffer. */
} ansiErrorReg_t;                      /* Register #124 Definition */
PACK_END

PACK_BEGIN
typedef struct PACK_MID
{
   HostMtrCommExceptionCnts_t exeCnts;       /* Register 1510 */
   HostMtrCommPerfSum_t       perfSum;       /* Register 1511 */
   ansiCResponseCodeErrs_t    ansiResp;      /* Register 1526 */
   HostMtrCommErrCntSum_t     errCntSum;     /* Register 1527 */
   ansiErrorReg_t             ansiErr;       /* Register 124 */
   uint16_t                   meterSessionFailureCount;
   uint16_t                   meterCommunicationLockoutCount;
   union
   {
      struct{
         uint8_t  Port0Err:  1;  //Too many retries?
         uint8_t  ISCErr:    1;  //Initial ISC error occurred
         uint8_t  RSVD:      6;  // Not used
      } Bits;
      uint8_t Byte;
   }uErrBits;
} mtrEngFileData_t; /* This is the order of the information in the file. */
PACK_END

/* GLOBAL VARIABLES */

/* FUNCTION PROTOTYPES */

returnStatus_t HMC_ENG_init(void);
void           HMC_ENG_Execute(uint8_t, HMC_COM_INFO *);
returnStatus_t HMC_ENG_getMeterSessionFailureCount( uint16_t *uMeterSessionFailureCount );
returnStatus_t HMC_ENG_setMeterSessionFailureCount( uint16_t uMeterSessionFailureCount );
returnStatus_t HMC_ENG_getMeterCommunicationLockoutCount( uint16_t *uMeterCommunicationLockoutCount );
returnStatus_t HMC_ENG_setMeterCommunicationLockoutCount( uint16_t uMeterCommunicationLockoutCount );
returnStatus_t HMC_ENG_getHmgEngStats( void* dst, lCnt size);

#endif
